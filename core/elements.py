import json,matplotlib.pyplot as plt,pandas
import random
import sys
import scipy.constants
from core.info import *
import scipy.special as spsp

#TODO: ESAME spiegare come si ottiene il calcolo di Line._optimized_power ponendo uguale a zero la derivata
# della formula nel modulo 8 alla slide 20

#TODO: ESAME per M bassi capita che Shannon dia average bitrate intero: ciò è dovuto al fatto che, quando una
# connessione riceverebbe da Shannon più bitrate di quello richiesto, l'eccedenza viene troncata

NUMBER_OF_CHANNELS=10
BERt=1e-3
Rs=32e9
Bn=12.5e9
f=193.414e12


class Node:
    """Class representing a node of the network"""
    def __init__(self, label:str, pos, connectedNodes, transceiver:str="fixed_rate"):
        self._label=label
        self._position=pos
        self._connected_nodes=connectedNodes
        self._successive={}  #linee adiacenti
        self._switching_matrix=None
        self._transceiver=transceiver   #fixed-rate, flex-rate or shannon

    @property
    def transceiver(self):
        return self._transceiver

    def propagate(self,sigIn:Lightpath,node1:str,node2:str,channelIndex:int):
        """Propagates the signal information through the node

        :param sigIn: signal information to be updated
        :param node1: node crossed before the current one
        :param node2: node to cross after the current one
        :param channelIndex: channel to occupy (-1 if no occupation is required)"""

        if channelIndex!=-1:
            self._switching_matrix[node1][node2][channelIndex]=0
        sigIn.updatePath(self._label)
        if len(sigIn.path)>1:
            try:
                sigIn._signal_power = self._successive[self._label+sigIn.path[0]].optimized_power
            except KeyError:
                print(self._label)

    @property
    def position(self):
        return self._position


class Line:
    #These values are here because we assume the every piece of fiber has the same characteristics
    alpha_dB=0.2e-3 #db/m
    alpha=alpha_dB/(20*math.log(math.e,10))
    beta_2=2.13e-26 #ps^2/km ?legato alla dispersione cromatica?
    gamma=1.27e-3 #1/(W*m)
    df=50e9 #Hz

    def __init__(self,newLab:str,newLen=0.0):
        self._label=newLab
        self._length=newLen
        self._successive={}  #nodi adiacenti
        self._state=[1 for i in range(NUMBER_OF_CHANNELS)]
        self._n_amplifiers=self._length//80e3
        self._gain=16 #dB
        self._noise_figure=3 #dB
        self._eta_nli=(16 / (27 * math.pi)) * \
               math.log(((math.pi ** 2) / 2) *
                        (self.beta_2 * (Rs ** 2) / self.alpha) *
                        (NUMBER_OF_CHANNELS ** (2 * Rs / self.df))) * \
               (self.gamma ** 2) / (4 * self.alpha * self.beta_2 * (Rs ** 3))#s/(W^2)
        self._optimized_power=self.optimized_launch_power()

    @property
    def state(self):
        return self._state

    @property
    def optimized_power(self):
        return self._optimized_power

    def latency_generation(self):
        return self._length/(scipy.constants.c*2/3)

    def noise_generation(self,sigPow:float):
        #return 1e-9*sigPow*self._length
        return self.ase_generation()+self.nli_generation()

    def propagate(self,sigIn:Signal_information,channel:int):
        """Updates the Signal_Information argument

        :param sigIn: Signal_information to be propagated
        :param channel: number of the the channel to occupy or -1 if no channel has to be occupied"""
        sigIn.update_latency(self.latency_generation())
        sigIn.update_signal_power(self.noise_generation(sigIn.signal_power))
        sigIn.update_noise(self.noise_generation(sigIn.signal_power))
        if channel != -1:
            self._state[channel]=0

    def occupy(self,channelIndex:int):
        """Sets the given channel of the line as occupied"""
        self._state[channelIndex]=0

    def freeAllChannels(self):
        self._state=[1for i in range(len(self._state))]

    def ase_generation(self):
        """Returns the amount of amplified spontaneous emissions in linear units generated by the line's amplifiers"""
        return self._n_amplifiers*scipy.constants.h*f*Bn*db2nu(self._noise_figure)*(db2nu(self._gain)-1)

    def nli_generation(self):
        nli=(self.optimized_power**3)*self._eta_nli*Bn*self._n_amplifiers
        return nli
        #real lines have a pre-amplifier and a boost amplifier, but we can assume they are combined and put n_amplifiers=n_spans

    def optimized_launch_power(self):
        return ((self.ase_generation()/self._n_amplifiers)/(2*self._eta_nli*Bn))**(1/3)


def db2nu(dbvalue:float):
    """Transforms a value in dB into its equivalent in natural units"""
    return 10**(dbvalue/10)


class Network:
    """Class representing a network

    :param filename: elenco nodi
    :type _nodes: dict
    """
    def __init__(self,filename:str,M=1,transceiver="fixed_rate"):
        self._nodes={}
        self._lines={}
        self._M=M
        self._saturated=False

        #toRead=open("/home/luchino/scuola/ovn/resources/nodes.json","r")
        toRead=open(filename,"r")
        dati=toRead.read()

        obj=json.loads(dati)    #reads the whole json file as a dictionary
        """for key in obj.keys():
        print(obj[key]["connected_nodes"])"""
        for key in obj.keys():  #every node is a {key:value} couple in the dictionary read with json.loads
            #nuoviPar={}
            #nuoviPar.update({"label":key})  #every key is the node name
            #every value associated to a label is a dictionary itself and contains the node's data
            #nuoviPar.update({chiave:obj[key][chiave]})
            if "transceiver" in obj[key].keys():
                newNode=Node(key, obj[key]["position"], obj[key]["connected_nodes"], obj[key]["transceiver"])
            else:
                newNode=Node(key, obj[key]["position"], obj[key]["connected_nodes"],transceiver)

            self._nodes.update({key:newNode})

        for nodo in self._nodes.values():
            #for every node in _nodes, a line is created between the node and the other nodes connected to it
            for adiac in nodo._connected_nodes:
                newLabel=nodo._label+adiac
                newDist=self.distance(nodo._label,adiac)
                self._lines.update({newLabel:Line(newLabel,newDist)})

        self.connect()

        self._T={}
        for node1 in self._nodes.keys():
            self._T.update({node1:{}})
            for node2 in self._nodes.keys():
                if node1!=node2 and self.find_paths(node1, node2):
                    self._T[node1].update({node2:100*self._M})
                else:
                    self._T[node1].update({node2:0})

        self._route_space=None  #dataframe indicating the free and occupied channels of each possible path
        self._weighted_paths=self.create_dataframe()
        #dataframe indicating various characteristics for each channel of each path

    @property
    def nodes(self):
        return self._nodes

    @property
    def weighted_paths(self):
        return self._weighted_paths

    @property
    def saturated(self):
        return self._saturated

    def distance(self,label1:str,label2:str):
        node1=self._nodes[label1]
        node2=self._nodes[label2]
        return math.sqrt((node1._position[0]-node2._position[0])**2+(node1._position[1]-node2._position[1])**2)

    def connect(self):
        """
        fills the _successive dictionaries present in every node/line to indicate the lines/nodes connected to it
        and createse the switching matrix for each node
        """
        for linea in self._lines.values():
            nodeLabel=linea._label[0]
            linea._successive.update({nodeLabel:self._nodes[nodeLabel]})
            self._nodes[nodeLabel]._successive.update({linea._label:linea})
        for nodo in self._nodes.values():
            nodo._switching_matrix={}
            #length=len(nodo._connected_nodes)
            new_dict={}
            for nodo2 in self._nodes.keys():#nodo._connected_nodes:
                for nodo3 in self._nodes.keys():#nodo._connected_nodes:
                    newVect=[]
                    if nodo2==nodo3 or (nodo._label not in self._nodes[nodo2]._connected_nodes) or (nodo3 not in self._nodes[nodo._label]._connected_nodes):
                        [newVect.append(0) for i in range(NUMBER_OF_CHANNELS)]
                    else:
                        [newVect.append(1) for i in range(NUMBER_OF_CHANNELS)]
                    new_dict.update({nodo3:copy.copy(newVect)})
                nodo._switching_matrix.update({nodo2:copy.copy(new_dict)})

    def find_paths(self,label1:str,label2:str):
        """Finds all the possible paths connecting two nodes

        :param label1: label for starting node
        :param label2: label for ending node
        :return: a list containing all the paths, represented as lists of node labels
        """
        if not (self._nodes.keys().__contains__(label1)) or not (self._nodes.keys().__contains__(label2)):
            print("Nodi inesistenti")
            return []
        found_paths=[]  #lista di tutte le soluzioni trovate
        percorso=[label1]  #lista in cui si salveranno i nodi attraversati
        crossable={}  #indica quali nodi siano attraversabili

        [crossable.update({nodo:True}) for nodo in self._nodes.keys()]
        """for nodo in self._nodes.keys():
            crossable.update({nodo:True})"""  #less efficient: in-line loops are preferable
        crossable[label1]=False
        self.find_pathsR(label1,label2,crossable,percorso,found_paths)
        return found_paths

    def find_pathsR(self,label1,label2,crossable,percorso,found_paths):
        """Recursive version of the wrapper function find_paths

        :param label1: starting node
        :param label2: ending node
        :param crossable: dictionary which associates every node label to the possibility of crossing it
        :param percorso: list of crossed nodes
        :param found_paths: list of paths already found
        """
        if label1==label2:
            found_paths.append(list.copy(percorso))
            return

        for line in self._nodes[label1]._successive.keys():
            if crossable[line[1]]:
                percorso.append(line[1])
                crossable[line[1]]=False
                self.find_pathsR(line[1],label2,crossable,percorso,found_paths)
                crossable[line[1]]=True
                percorso.remove(line[1])

    @staticmethod
    def multiply_vectors(v1:list,v2:list):
        toReturn=[v1[i]*v2[i] for i in range(len(v1))]
        return toReturn

    def propagate(self,sigIn:Lightpath,channel:int):  #we can assume only correct paths can be passed
        """
        It can propagate the Signal_information without occupying the crossed path: this is useful if you want to just
        simulate the crossing of a lightpath

        :param sigIn: the Signal_information to propagate
        :param channel: the channel we want to make the Signal_information to propagate on; it must be -1 if you want to use the method just as a simulation method without occupying any channel
        """
        path=copy.copy(sigIn.path)

        if channel != -1:   #this part will be executed only if a channel has to be occupied
            toUpdate=[]
            for i in range(len(path) - 1):  #iterates on every line in the path
                #toUpdate=[]
                #self._lines[path[i] + path[i + 1]].occupy(channel)
                for label in self._route_space.index.tolist():
                    if path[i]+"->"+path[1+i] in label:
                        toUpdate.append(label)
                self._lines[path[i] + path[i + 1]].propagate(sigIn, channel)
            toUpdate=list(set(toUpdate))
            sigIn.updatePath(path[0])

            for j in range(len(path)-1)[1:len(path)-1]:
                self._nodes[path[j]].propagate(sigIn,path[j-1],path[j+1],channel)
            for lab in toUpdate:
                label=self.path_to_list(lab)
                vect=[1 for i in range(NUMBER_OF_CHANNELS)]
                for i in range(len(label)-1):   #moltiplica per tutti i vettori di stato delle linee del path
                    vect=self.multiply_vectors(vect,self._lines[label[i]+label[i+1]].state)
                for i in range(len(label)-1)[1:]:
                    vect=self.multiply_vectors(vect,self._nodes[label[i]]._switching_matrix[label[i-1]][label[i+1]])
                self._route_space.loc[lab]=copy.copy(vect)
        else:
            [self._nodes[nodo].propagate(sigIn, "", "", channel) for nodo in list.copy(path)]
            [self._lines[path[i] + path[i + 1]].propagate(sigIn, channel) for i in range(len(path) - 1)]

        return sigIn

    def draw(self):
        for linea in self._lines.values():
            p1=self._nodes[linea._label[0]]
            p2=self._nodes[linea._label[1]]
            x=[p1.position[0], p2.position[0]]
            y=[p1.position[1],p2.position[1]]
            plt.plot(x,y)
        for nodo in self._nodes.values():
            plt.scatter(nodo._position[0],nodo._position[1])
            plt.annotate(nodo._label,nodo._position)
        plt.show()

    @staticmethod
    def list_to_path(listIn:list):
        strOut=""
        for i in range(len(listIn)-1):
            strOut+=(listIn[i]+"->")
        strOut+=listIn[len(listIn)-1]
        return strOut

    @staticmethod
    def list_to_string(listIn):
        """transforms a labels list into a string, useful to initialize the Signal_information variable of create_dataframe"""
        strOut=""
        for nodo in listIn:
            strOut+=nodo
        return strOut

    @staticmethod
    def path_to_list(path:str):
        toReturn=[]
        [toReturn.append(label) for label in path.split('->')]
        return toReturn

    def create_dataframe(self):
        """Creates a pandas dataframe associating every possible path in the net with its latency, noise and SNR"""
        """data={'apples':[3,2,0,1],'oranges':[0,3,7,2]}
        purchases=pandas.DataFrame(data,index=['June','Robert','Lily','David'])
        print(purchases.to_string())"""
        initial_power=1e-3
        data={"latency":[],"noise":[],"GSNR":[]}
        data2={}
        [data2.update({i:[]}) for i in range(NUMBER_OF_CHANNELS)]
        indexes=[]
        for nodo1 in self._nodes.values():
            for nodo2 in self._nodes.values():
                if nodo1==nodo2:
                    indexes.append(nodo1._label)
                    data["latency"].append(0)
                    data["noise"].append(0)
                    data["GSNR"].append(0)
                    [data2[i].append(1) for i in range(NUMBER_OF_CHANNELS)]
                else:
                    for percorso in self.find_paths(nodo1._label,nodo2._label):
                        indexes.append(self.list_to_path(percorso))
                        #sig=Signal_information(initial_power,self.list_to_string(percorso))
                        sig = Lightpath(2, percorso)
                        self.propagate(sig,-1)
                        data["latency"].append(sig.latency)
                        data["noise"].append(sig.noise_power)
                        data["GSNR"].append(10*math.log(self.calculate_GSNR(sig),10))
                        [data2[i].append(1) for i in range(NUMBER_OF_CHANNELS)]
        toReturn=pandas.DataFrame(data,indexes)
        self._route_space=pandas.DataFrame(data2,indexes)
        return toReturn

    def available_path(self,pathAsList:list):
        """
        :param pathAsList: the path you want to cross (passed as list of crossed nodes' labels)
        :return: a boolean value indicating whether there is a free channel for the given path or not
        """

        #Old implementation with single-channel lines:
        # for i in range(len(pathAsList)-1):
        #     if self._lines[pathAsList[i]+pathAsList[i+1]].state==0:
        #         return False
        # return True

        path=self.list_to_path(pathAsList)
        for i in range(NUMBER_OF_CHANNELS):
            if self._route_space.loc[path][i]==1:
                return True
        return False    #we get to this point only if no free channel is found

    def find_best_snr(self,n1: str ,n2: str):
        """
        :param n1: start node label
        :param n2: end node label
        :return: path (as a string) giving the highest SNR (the string will be empty if no available path is found)
        """

        #NOTES ON HOW TO MANAGE PANDAS DATAFRAMES
        #net._weighted_paths.index #returns all indexes
        #net._weighted_paths.loc[label][columnName] #returns the value at label row and columnName column
        #net._weighted_paths.loc['A->B']  #returns information about the row with 'A->B' index
        bestPath=""
        biggestSNR=0.0
        for label in self._weighted_paths.index:    #label will be a string like "A->B->C"
            if label[0]==n1 and label[-1]==n2:
                if self.available_path(self.path_to_list(label)): #checks if at least one line in the path is free
                    newSNR = self._weighted_paths.loc[label]['GSNR']
                    if newSNR>biggestSNR:
                        biggestSNR=newSNR
                        bestPath=copy.copy(label)
        if biggestSNR>0.0:
            return bestPath
        else:
            return ""

    def find_best_latency(self, n1:str, n2:str):
        """
        :param n1: start node
        :param n2: end node
        :return: the path in the form "A->B->..." giving the lowest latency (the string will be empty if no available path is found)
        """

        bestPath=""
        lowestLatency=sys.maxsize
        for label in self._weighted_paths.index:
            if label[0]==n1 and label[len(label)-1]==n2:
                if self.available_path(self.path_to_list(label)):  #checks if all lines in the path are free
                    newLatency=self._weighted_paths.loc[label]['latency']
                    if newLatency<lowestLatency:
                        lowestLatency=newLatency
                        bestPath=copy.copy(label)
        return bestPath

    def occupy_path(self,path:list,channelIndex:int):
        """Sets as occupied all lines in the given path

        :param path: the list of the crossed nodes' labels
        :param channelIndex: index of the channel to occcupy in every line of the path
        """
        for i in range(len(path) - 1):  #iterates on every line in the path
            #self._lines[path[i]+path[i+1]].state[channelIndex]=0
            self._lines[path[i] + path[i + 1]].occupy(channelIndex)
            for label in self._route_space.index:
                if path[i]+"->"+path[i+1] in label:
                    self._route_space.loc[label][channelIndex]=0

    def free_all_lines(self):
        """Sets every line as free: useful if called at the end of stream, it allows to perform a new simulation"""
        for linea in self._lines.values():
            linea.freeAllChannels()
        self.update_dataframe()


    def first_free_channel(self,path:str):
        """:param path: a path in the form "A->B->..."
        :return: the index of the first free channel available in the given path"""
        for i in range(NUMBER_OF_CHANNELS):
            if self._route_space.loc[path][i]==1:
                return i
        return -1   #this line should never be reached, since we
        #assume that this method only gets called upon paths with at least one free channel

    def stream(self,connections:list,choice:str="latency"):
        """
        Updates every connection in the list setting its latency and SNR to the
        ones it would have if it crossed the path giving the best latency/snr

        :param connections: list of Connection objects
        :param choice: indicates if the chosen path has to give the highest snr or the lowest latency
        """
        if choice == "latency":
            for conn in connections:
                bestPath=self.find_best_latency(conn.input,conn.output)
                if bestPath=="":
                    conn.snr=0
                    conn.latency=None
                else:
                    newPath=self.path_to_list(bestPath)
                    sigInf=Lightpath(conn.signal_power,newPath)
                    sigInf._channel = self.first_free_channel(bestPath)
                    self.propagate(sigInf, sigInf.channel)
                    conn.latency=sigInf.latency
                    conn.snr=self.calculate_GSNR(sigInf)
            self.free_all_lines()
        elif choice == "snr":
            for conn in connections:
                bestPath=self.find_best_snr(conn.input,conn.output)
                if bestPath == "":   #if no path is available, default values are set
                    conn.snr=0
                    conn.latency=None
                else:
                    bitrate=self.calculate_bit_rate(bestPath,self._nodes[bestPath[0]].transceiver)
                    if bitrate==0:
                        conn.snr=0
                        conn.latency=None
                    else:
                        newPath=self.path_to_list(bestPath)
                        sigInf=Lightpath(conn.signal_power,newPath)
                        Lightpath._channel = self.first_free_channel(bestPath)
                        self.propagate(sigInf, sigInf.channel)
                        conn.latency=sigInf.latency
                        conn.snr=self.calculate_GSNR(sigInf)
                    conn.bit_rate=bitrate
            #print(self._route_space.to_string())
            self.free_all_lines()
        else:
            print("Choice must be \"latency\" or \"snr\"")

    def calculate_bit_rate(self,path:str,strategy:str):
        """
        Evaluates the bit rate supported by a specific path

        :param path: the path to examine
        :param strategy: a string among "fixed_rate", "flex_rate" and "shannon" (any other string will be rejected)
        :return: the bit rate in Gbps supported by the path
        """
        gsnr=db2nu(self._weighted_paths.loc[path]["GSNR"])
        if strategy=="fixed_rate":
            if gsnr>=2*(spsp.erfcinv(2*BERt)**2)*Rs/Bn:
                return 100
            else:
                return 0
        elif strategy=="flex_rate":
            if gsnr>=10*(spsp.erfcinv((8/3)*BERt)**2)*(Rs/Bn):   #115.489
                return 400
            elif gsnr>=(14/3)*(spsp.erfcinv((3/2)*BERt)**2)*(Rs/Bn):   #60.203
                return 200
            elif gsnr>=2*(spsp.erfcinv(2*BERt)**2)*(Rs/Bn):    #24.447
                return 100
            else:
                return 0
        elif strategy=="shannon":
            #return 2*Rs*math.log(1+(Bn/Rs)*gsnr, 2)/1e9
            return 2*Rs*math.log(1+(Rs/Bn)*gsnr, 2)/1e9
        else:
            print("Strategy must be fixed_rate, flex_rate or shannon\n")
            toReturn=-1
        return toReturn

    def calculate_GSNR(self,sigIn):
        """
        :param sigIn: the Lightpath of which we want to calculate the GSNR
        :return: the Lightpath's GSNR calculated as one over the sum of all lines' ISNRs
        """
        isnr=0
        for i in range((len(sigIn.constant_path))-1):
            linea=self._lines[sigIn.constant_path[i]+sigIn.constant_path[i+1]]
            #isnr+=1/self._lines[sigIn.constant_path[i]+sigIn.constant_path[i+1]].optimized_power
            isnr+=(linea.noise_generation(linea.optimized_power))/linea.optimized_power#ISNR=1/GSNR
        return 1/isnr

    def test_network(self,M:int):
        """
        Creates 100 connections between random nodes and tries to allocate them according to the the network's T matrix

        :param M: initial value of every cell in matrix T
        :return: a list containing every accepted connection
        """
        self._saturated=False
        if self._M!=M:
            self.update_M(M)

        couples=[]  #list containing all source-destination couples; it becomes empty when the net reaches saturation
        #a couple will be removed from the list if its cell in T becomes 0 or if there is no available path from A to B
        acceptedConnections=[]
        for node1 in self._nodes.keys():
            for node2 in self._nodes.keys():
                if node1!=node2: couples.append(node1+node2)

        while len(couples)!=0:
        #pairs= ['EF', 'CA', 'AE', 'CD', 'EB', 'BD', 'FC', 'BE', 'CA', 'DF', 'EB', 'BC', 'DC', 'EF', 'ED', 'BE', 'CA','AB', 'FB', 'FB', 'AC', 'AD', 'DB', 'AD', 'BE', 'DB', 'FE', 'AD', 'BE', 'BF', 'AD', 'DB', 'FC', 'AC','BF', 'AC', 'DB', 'EA', 'EC', 'CB', 'DF', 'EC', 'BA', 'AF', 'EC', 'FC', 'BD', 'ED', 'EF', 'EA', 'BA','FB', 'FE', 'DB', 'FC', 'BA', 'CF', 'DE', 'BA', 'CB', 'EC', 'CB', 'CE', 'AF', 'CD', 'DA', 'CA', 'DA','BA', 'FB', 'AF', 'BE', 'FB', 'BF', 'DB', 'AD', 'FD', 'CA', 'CD', 'DC', 'CD', 'CE', 'BC', 'AD', 'BE','DC', 'DA', 'EC', 'CE', 'BF', 'AB', 'FD', 'DE', 'BC', 'FA', 'EA', 'DF', 'BE', 'CE', 'DC']
        #for i in range(len(pairs)):
            #couple=pairs[i]
            max_bitrate=0
            couple=random.choice(couples)
            if self._T[couple[0]][couple[1]]>0:
                bestPath=self.find_best_snr(couple[0],couple[1])
                if bestPath=="":
                    pass
                    couples.remove(couple)
                else:
                    bitrate=self.calculate_bit_rate(bestPath,self._nodes[bestPath[0]].transceiver)
                    if bitrate!=0:
                        if self._T[couple[0]][couple[1]]>bitrate:
                            self._T[couple[0]][couple[1]]-=bitrate
                        else:
                            max_bitrate=bitrate
                            bitrate=self._T[couple[0]][couple[1]]
                            self._T[couple[0]][couple[1]]=0

                        newPath=self.path_to_list(bestPath)
                        conn=Connection(couple[0],couple[1],self._lines[newPath[0]+newPath[1]].optimized_power,newPath)
                        conn.max_bit_rate=max_bitrate
                        sigInf=Lightpath(conn.signal_power,newPath)
                        sigInf._channel=self.first_free_channel(bestPath)
                        self.propagate(sigInf, sigInf.channel)
                        conn.latency=sigInf.latency
                        conn.snr=self.calculate_GSNR(sigInf)
                        conn.bit_rate=bitrate
                        acceptedConnections.append(copy.copy(conn))
                        pass
                    else:
                        couples.remove(couple)
                        pass
            else:
                couples.remove(couple)
                pass

        #print(self._T)
        tot=0
        for vect in self._T.values():
            tot+=sum(vect.values())
        self._saturated=(tot>0)
        self.free_all_lines()
        self.connect()
        return acceptedConnections

    def update_M(self,M:int):
        """
        Updates the T matrix assigning the value M*100 Gbps to every cell where source and destination are different

        :param M: the new value of M
        """
        self._M=M
        for node1 in self._nodes.keys():
            for node2 in self._nodes.keys():
                if node1!=node2 and self.find_paths(node1,node2):
                   self._T[node1][node2]=100*M
                else:
                    self._T[node1][node2]=0

    def update_dataframe(self):
        data2={}
        [data2.update({i:[]}) for i in range(NUMBER_OF_CHANNELS)]
        indexes=[]
        for nodo1 in self._nodes.values():
            for nodo2 in self._nodes.values():
                if nodo1==nodo2:
                    indexes.append(nodo1._label)
                    [data2[i].append(1) for i in range(NUMBER_OF_CHANNELS)]
                else:
                    for percorso in self.find_paths(nodo1._label, nodo2._label):
                        indexes.append(self.list_to_path(percorso))
                        [data2[i].append(1) for i in range(NUMBER_OF_CHANNELS)]
        self._route_space=pandas.DataFrame(data2, indexes)
